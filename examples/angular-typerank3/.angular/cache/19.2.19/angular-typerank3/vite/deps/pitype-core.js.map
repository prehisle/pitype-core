{
  "version": 3,
  "sources": ["../../../../../../../../packages/pitype-core/dist/tokenizer.js", "../../../../../../../../packages/pitype-core/dist/textSource.js", "../../../../../../../../packages/pitype-core/dist/typingSession.js", "../../../../../../../../packages/pitype-core/dist/statsTracker.js", "../../../../../../../../packages/pitype-core/dist/recorder.js", "../../../../../../../../packages/pitype-core/dist/sessionRuntime.js", "../../../../../../../../packages/pitype-core/dist/dom/inputController.js", "../../../../../../../../packages/pitype-core/dist/dom/statsPanel.js", "../../../../../../../../packages/pitype-core/dist/dom/themeController.js", "../../../../../../../../packages/pitype-core/dist/dom/textRenderer.js", "../../../../../../../../packages/pitype-core/dist/dom/cursorAdapter.js", "../../../../../../../../packages/pitype-core/dist/dom/audioController.js", "../../../../../../../../packages/pitype-core/dist/player.js", "../../../../../../../../packages/pitype-core/dist/ghostManager.js", "../../../../../../../../packages/pitype-core/dist/locale.js"],
  "sourcesContent": ["const ENGLISH_RE = /[A-Za-z0-9]/;\nconst CHINESE_RE = /[\\u3400-\\u9FBF]/;\nconst FULL_WIDTH_SPACE = '\\u3000';\nconst PUNCTUATION_SET = new Set([\n    ',',\n    '.',\n    '!',\n    '?',\n    ';',\n    ':',\n    '\"',\n    \"'\",\n    '-',\n    '_',\n    '(',\n    ')',\n    '[',\n    ']',\n    '{',\n    '}',\n    '，',\n    '。',\n    '！',\n    '？',\n    '：',\n    '；',\n    '「',\n    '」',\n    '『',\n    '』',\n    '（',\n    '）',\n    '、',\n    '—',\n    '…',\n    '·',\n    '《',\n    '》',\n    '：',\n    '！',\n    '？'\n]);\nexport function tokenizeText(text) {\n    const tokens = [];\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === '\\r') {\n            continue; // 忽略 Windows 换行中的 \\r\n        }\n        if (char === '\\n') {\n            tokens.push({\n                char,\n                type: 'newline',\n                language: 'separator',\n                attachToPrevious: false\n            });\n            continue;\n        }\n        if (char === ' ' || char === FULL_WIDTH_SPACE) {\n            tokens.push({\n                char,\n                type: 'space',\n                language: 'separator',\n                attachToPrevious: tokens.length > 0\n            });\n            continue;\n        }\n        if (PUNCTUATION_SET.has(char)) {\n            tokens.push({\n                char,\n                type: 'punctuation',\n                language: 'separator',\n                attachToPrevious: tokens.length > 0\n            });\n            continue;\n        }\n        const language = CHINESE_RE.test(char)\n            ? 'chinese'\n            : ENGLISH_RE.test(char)\n                ? 'english'\n                : 'other';\n        tokens.push({\n            char,\n            type: 'char',\n            language,\n            attachToPrevious: false\n        });\n    }\n    return tokens;\n}\n", "import { tokenizeText } from './tokenizer.js';\nlet sourceCounter = 0;\nexport function createTextSource(content, options = {}) {\n    if (!content) {\n        throw new Error('TextSource content must not be empty');\n    }\n    return {\n        id: options.id ?? `text-${++sourceCounter}`,\n        content,\n        locale: options.locale,\n        tokens: options.tokens ?? tokenizeText(content)\n    };\n}\n", "import { createTextSource } from './textSource.js';\nexport class TypingSession {\n    constructor(options) {\n        this.listeners = new Set();\n        this.entries = [];\n        this.position = 0;\n        this.completed = false;\n        const source = options?.source ?? createTextSourceFromOptions(options);\n        if (!source) {\n            throw new Error('TypingSession requires text or source');\n        }\n        this.text = source.content;\n        this.now = options.now ?? (() => Date.now());\n        this.tokens = source.tokens;\n        this.locale = source.locale;\n        this.sourceId = source.id;\n    }\n    subscribe(listener) {\n        this.listeners.add(listener);\n        return () => this.listeners.delete(listener);\n    }\n    getState() {\n        return {\n            text: this.text,\n            position: this.position,\n            entries: [...this.entries],\n            complete: this.completed,\n            sourceId: this.sourceId,\n            locale: this.locale\n        };\n    }\n    isComplete() {\n        return this.completed;\n    }\n    input(chars) {\n        if (!chars)\n            return;\n        for (const char of chars) {\n            if (this.position >= this.tokens.length) {\n                this.completed = true;\n                return;\n            }\n            if (this.startedAt === undefined) {\n                this.startSession();\n            }\n            const expected = this.tokens[this.position]?.char ?? '';\n            const timestamp = this.now();\n            const correct = this.equalsInput(expected, char);\n            const entry = {\n                index: this.position,\n                expected,\n                actual: char,\n                correct\n            };\n            this.entries.push(entry);\n            this.position += 1;\n            this.emit({ type: 'input:evaluate', timestamp, ...entry });\n            if (this.position >= this.tokens.length) {\n                this.completed = true;\n                this.emit({ type: 'session:complete', timestamp });\n                return;\n            }\n        }\n    }\n    undo(count = 1) {\n        if (count <= 0)\n            return;\n        while (count-- > 0 && this.entries.length > 0) {\n            const entry = this.entries.pop();\n            this.position = entry.index;\n            this.completed = false;\n            const timestamp = this.now();\n            this.emit({ type: 'input:undo', timestamp, ...entry });\n        }\n    }\n    reset() {\n        this.entries = [];\n        this.position = 0;\n        this.completed = false;\n        this.startedAt = undefined;\n        this.emit({ type: 'session:reset', timestamp: this.now() });\n    }\n    startSession() {\n        this.startedAt = this.now();\n        this.emit({ type: 'session:start', timestamp: this.startedAt });\n    }\n    emit(event) {\n        this.listeners.forEach((listener) => listener(event));\n    }\n    equalsInput(expected, actual) {\n        if (expected === actual)\n            return true;\n        if (expected === '\\n' && (actual === '\\n' || actual === '\\r'))\n            return true;\n        return false;\n    }\n}\nfunction createTextSourceFromOptions(options) {\n    if (!options?.text)\n        return undefined;\n    return createTextSource(options.text, { tokens: options.tokens });\n}\n", "export function createStatsTracker(session) {\n    return new StatsTrackerImpl(session);\n}\nclass StatsTrackerImpl {\n    constructor(session) {\n        this.correctChars = 0;\n        this.totalChars = 0;\n        this.completed = false;\n        session.subscribe((event) => this.handleEvent(event));\n    }\n    getSnapshot() {\n        const durationMs = this.computeDuration();\n        const minutes = durationMs > 0 ? durationMs / 60000 : 0;\n        return {\n            startedAt: this.startedAt,\n            durationMs,\n            correctChars: this.correctChars,\n            totalChars: this.totalChars,\n            accuracy: this.totalChars === 0 ? 100 : Math.round((this.correctChars / this.totalChars) * 100),\n            correctCpm: minutes > 0 ? Math.round(this.correctChars / minutes) : 0,\n            totalCpm: minutes > 0 ? Math.round(this.totalChars / minutes) : 0,\n            wpm: minutes > 0 ? Math.round(this.correctChars / minutes / 5) : 0,\n            completed: this.completed\n        };\n    }\n    handleEvent(event) {\n        switch (event.type) {\n            case 'session:start':\n                this.startedAt = event.timestamp;\n                this.lastTimestamp = event.timestamp;\n                this.completed = false;\n                this.correctChars = 0;\n                this.totalChars = 0;\n                break;\n            case 'input:evaluate':\n                this.lastTimestamp = event.timestamp;\n                this.totalChars += 1;\n                if (event.correct)\n                    this.correctChars += 1;\n                break;\n            case 'input:undo':\n                this.lastTimestamp = event.timestamp;\n                if (this.totalChars > 0)\n                    this.totalChars -= 1;\n                if (event.correct && this.correctChars > 0)\n                    this.correctChars -= 1;\n                this.completed = false;\n                break;\n            case 'session:complete':\n                this.lastTimestamp = event.timestamp;\n                this.completed = true;\n                break;\n            case 'session:reset':\n                this.startedAt = undefined;\n                this.lastTimestamp = undefined;\n                this.totalChars = 0;\n                this.correctChars = 0;\n                this.completed = false;\n                break;\n        }\n    }\n    computeDuration() {\n        if (this.startedAt === undefined) {\n            return 0;\n        }\n        const last = this.lastTimestamp ?? this.startedAt;\n        return Math.max(0, last - this.startedAt);\n    }\n}\n", "export function createRecorder(options = {}) {\n    const { id: customId, includeMetadata = true, customMetadata = {} } = options;\n    let recording = false;\n    let _currentSession = null;\n    let currentTextSource = null;\n    let events = [];\n    let startTime = 0;\n    let unsubscribe = null;\n    let recordingId = '';\n    function generateId() {\n        return customId || `recording-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    function start(session, textSource) {\n        if (recording) {\n            console.warn('Recording already in progress. Stop current recording first.');\n            return;\n        }\n        // 重置状态\n        recording = true;\n        _currentSession = session;\n        currentTextSource = textSource;\n        events = [];\n        startTime = Date.now();\n        recordingId = generateId();\n        // 订阅会话事件\n        unsubscribe = session.subscribe((event) => {\n            if (recording) {\n                events.push({ ...event });\n            }\n        });\n    }\n    function stop(finalStats) {\n        if (!recording || !currentTextSource) {\n            console.warn('No recording in progress.');\n            return null;\n        }\n        // 取消订阅\n        if (unsubscribe) {\n            unsubscribe();\n            unsubscribe = null;\n        }\n        const endTime = Date.now();\n        recording = false;\n        // 构建录制数据\n        const recordingData = {\n            id: recordingId,\n            textSource: currentTextSource,\n            events: [...events],\n            startTime,\n            endTime,\n            finalStats\n        };\n        // 添加元数据\n        if (includeMetadata) {\n            recordingData.metadata = {\n                version: '1.0.0',\n                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n                duration: endTime - startTime,\n                eventCount: events.length,\n                ...customMetadata\n            };\n        }\n        // 清理当前状态\n        _currentSession = null;\n        currentTextSource = null;\n        events = [];\n        return recordingData;\n    }\n    function isRecording() {\n        return recording;\n    }\n    function getCurrentRecording() {\n        if (!recording || !currentTextSource) {\n            return null;\n        }\n        return {\n            id: recordingId,\n            textSource: currentTextSource,\n            events: [...events],\n            startTime,\n            endTime: Date.now()\n        };\n    }\n    function clear() {\n        if (unsubscribe) {\n            unsubscribe();\n            unsubscribe = null;\n        }\n        recording = false;\n        _currentSession = null;\n        currentTextSource = null;\n        events = [];\n        startTime = 0;\n        recordingId = '';\n    }\n    return {\n        start,\n        stop,\n        isRecording,\n        getCurrentRecording,\n        clear\n    };\n}\n/**\n * 将录制数据序列化为 JSON 字符串\n */\nexport function serializeRecording(recording) {\n    return JSON.stringify(recording, null, 2);\n}\n/**\n * 从 JSON 字符串反序列化录制数据\n */\nexport function deserializeRecording(json) {\n    return JSON.parse(json);\n}\n/**\n * 导出录制数据到文件（浏览器环境）\n */\nexport function exportRecordingToFile(recording, filename) {\n    if (typeof window === 'undefined' || typeof Blob === 'undefined') {\n        throw new Error('File export is only available in browser environments');\n    }\n    const json = serializeRecording(recording);\n    const blob = new Blob([json], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename || `${recording.id}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n}\n/**\n * 从文件导入录制数据（浏览器环境）\n */\nexport function importRecordingFromFile(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            try {\n                const json = event.target?.result;\n                const recording = deserializeRecording(json);\n                resolve(recording);\n            }\n            catch (error) {\n                reject(new Error(`Failed to parse recording file: ${error}`));\n            }\n        };\n        reader.onerror = () => {\n            reject(new Error('Failed to read file'));\n        };\n        reader.readAsText(file);\n    });\n}\n", "import { createStatsTracker } from './statsTracker.js';\nimport { TypingSession } from './typingSession.js';\nimport { createRecorder } from './recorder.js';\nimport { tokenizeText } from './tokenizer.js';\nexport function createSessionRuntime(options = {}) {\n    const interval = options.snapshotIntervalMs ?? 1000;\n    const audioController = options.audioController;\n    const enableRecording = options.enableRecording ?? false;\n    const recorderOptions = options.recorderOptions;\n    let typingSession = null;\n    let statsTracker = null;\n    let timer = null;\n    let unsubscribe = null;\n    // 录制相关状态\n    let recorder = enableRecording ? createRecorder(recorderOptions) : null;\n    let lastRecording = null;\n    let currentTextSource = null;\n    const getSnapshot = () => (statsTracker ? statsTracker.getSnapshot() : null);\n    const notifySnapshot = () => {\n        options.onSnapshot?.(getSnapshot());\n    };\n    const startTimer = () => {\n        if (interval <= 0 || timer)\n            return;\n        timer = setInterval(() => {\n            notifySnapshot();\n        }, interval);\n    };\n    const stopTimer = () => {\n        if (timer) {\n            clearInterval(timer);\n            timer = null;\n        }\n    };\n    const teardownSession = () => {\n        stopTimer();\n        if (unsubscribe) {\n            unsubscribe();\n            unsubscribe = null;\n        }\n        typingSession = null;\n        statsTracker = null;\n    };\n    const handleSessionEvent = (event) => {\n        switch (event.type) {\n            case 'session:start':\n                startTimer();\n                notifySnapshot();\n                break;\n            case 'input:evaluate':\n                options.onEvaluate?.(event);\n                notifySnapshot();\n                // 触发音效：按键音 + 正确/错误音\n                if (audioController) {\n                    audioController.playSound('keyPress');\n                    if (event.correct) {\n                        audioController.playSound('correct');\n                    }\n                    else {\n                        audioController.playSound('error');\n                    }\n                }\n                break;\n            case 'input:undo':\n                options.onUndo?.(event);\n                notifySnapshot();\n                break;\n            case 'session:complete': {\n                stopTimer();\n                notifySnapshot();\n                const finalSnapshot = getSnapshot();\n                // 停止录制（必须在 onComplete 之前，这样回调中可以获取到录制数据）\n                if (recorder && recorder.isRecording()) {\n                    lastRecording = recorder.stop(finalSnapshot || undefined);\n                }\n                // 调用完成回调\n                options.onComplete?.(finalSnapshot);\n                // 触发完成音效\n                audioController?.playSound('complete');\n                break;\n            }\n            case 'session:reset':\n                stopTimer();\n                notifySnapshot();\n                options.onReset?.();\n                // 停止录制（如果正在录制）\n                if (recorder && recorder.isRecording()) {\n                    recorder.stop();\n                }\n                break;\n        }\n    };\n    const dispose = () => {\n        teardownSession();\n        notifySnapshot();\n    };\n    const startSession = (input) => {\n        teardownSession();\n        const session = createSessionFromInput(input);\n        typingSession = session;\n        statsTracker = createStatsTracker(session);\n        unsubscribe = session.subscribe(handleSessionEvent);\n        // 获取文本源\n        currentTextSource = extractTextSource(input);\n        // 开始录制（如果启用）\n        if (recorder && currentTextSource) {\n            recorder.start(session, currentTextSource);\n        }\n        notifySnapshot();\n        return session;\n    };\n    return {\n        startSession,\n        dispose,\n        getSession: () => typingSession,\n        getLatestSnapshot: getSnapshot,\n        getRecorder: () => recorder,\n        getLastRecording: () => lastRecording,\n        isRecording: () => recorder?.isRecording() ?? false\n    };\n}\nfunction createSessionFromInput(input) {\n    if (typeof input === 'string') {\n        return new TypingSession({ text: input });\n    }\n    if (typeof input === 'object' && 'content' in input && 'tokens' in input) {\n        return new TypingSession({ source: input });\n    }\n    return new TypingSession(input);\n}\nfunction extractTextSource(input) {\n    if (typeof input === 'string') {\n        // 从字符串创建一个简单的 TextSource\n        return {\n            content: input,\n            tokens: tokenizeText(input),\n            id: `text-${Date.now()}`,\n            locale: 'en-US'\n        };\n    }\n    if (typeof input === 'object' && 'content' in input && 'tokens' in input) {\n        return input;\n    }\n    if (typeof input === 'object' && 'source' in input && input.source) {\n        return input.source;\n    }\n    return null;\n}\n", "const compositionTriggerPattern = /[\\u4e00-\\u9fa5a-zA-Z]/;\nexport function createDomInputController(options = {}) {\n    const { getTypingSession = () => null, isResultModalVisible = () => false, onCompositionEnd = () => { }, documentRef = typeof document !== 'undefined' ? document : undefined, getActiveElement = () => typeof document !== 'undefined' ? document.activeElement : null } = options;\n    let inputElement = null;\n    let isComposing = false;\n    let potentialCompositionStart = false;\n    const handleInputEvent = () => {\n        if (!inputElement || isComposing)\n            return;\n        if (potentialCompositionStart) {\n            const currentValue = inputElement.value;\n            inputElement.value = '';\n            if (!isComposing && currentValue) {\n                inputElement.value = currentValue;\n                const tempState = potentialCompositionStart;\n                potentialCompositionStart = false;\n                handleInputEvent();\n                potentialCompositionStart = tempState;\n            }\n            return;\n        }\n        const session = getTypingSession();\n        if (!session) {\n            inputElement.value = '';\n            return;\n        }\n        const inputChar = inputElement.value;\n        inputElement.value = '';\n        if (!inputChar)\n            return;\n        session.input(inputChar);\n    };\n    const handlePotentialCompositionKeydown = (event) => {\n        if (!isComposing &&\n            typeof event.key === 'string' &&\n            event.key.length === 1 &&\n            compositionTriggerPattern.test(event.key)) {\n            potentialCompositionStart = true;\n        }\n    };\n    const handlePotentialCompositionKeyup = () => {\n        if (potentialCompositionStart && !isComposing) {\n            potentialCompositionStart = false;\n        }\n    };\n    const handleCompositionStart = () => {\n        isComposing = true;\n        potentialCompositionStart = false;\n    };\n    const handleCompositionEnd = () => {\n        isComposing = false;\n        if (inputElement && inputElement.value) {\n            handleInputEvent();\n        }\n        onCompositionEnd();\n    };\n    const focusInput = (focusOptions) => {\n        if (!inputElement)\n            return;\n        if (typeof inputElement.focus === 'function') {\n            inputElement.focus(focusOptions ?? { preventScroll: true });\n        }\n    };\n    const handleDocumentKeydown = (event) => {\n        if (isResultModalVisible() || !inputElement)\n            return;\n        const session = getTypingSession();\n        if (!session)\n            return;\n        const key = typeof event.key === 'string' ? event.key : '';\n        const isCharacterOperation = key.length === 1 || key === 'Backspace' || key === 'Enter';\n        if (isCharacterOperation && getActiveElement() !== inputElement) {\n            event.preventDefault?.();\n            focusInput();\n        }\n        if (key === 'Enter') {\n            event.preventDefault?.();\n            if (!isComposing) {\n                session.input('\\n');\n            }\n            return;\n        }\n        if (key === 'Backspace') {\n            event.preventDefault?.();\n            session.undo();\n        }\n    };\n    const attachInput = (element) => {\n        detachInput();\n        if (!element)\n            return;\n        inputElement = element;\n        inputElement.addEventListener('input', handleInputEvent);\n        inputElement.addEventListener('keydown', handlePotentialCompositionKeydown);\n        inputElement.addEventListener('keyup', handlePotentialCompositionKeyup);\n        inputElement.addEventListener('compositionstart', handleCompositionStart);\n        inputElement.addEventListener('compositionend', handleCompositionEnd);\n    };\n    const detachInput = () => {\n        if (!inputElement)\n            return;\n        inputElement.removeEventListener('input', handleInputEvent);\n        inputElement.removeEventListener('keydown', handlePotentialCompositionKeydown);\n        inputElement.removeEventListener('keyup', handlePotentialCompositionKeyup);\n        inputElement.removeEventListener('compositionstart', handleCompositionStart);\n        inputElement.removeEventListener('compositionend', handleCompositionEnd);\n        inputElement = null;\n        potentialCompositionStart = false;\n        isComposing = false;\n    };\n    documentRef?.addEventListener('keydown', handleDocumentKeydown);\n    const destroy = () => {\n        detachInput();\n        documentRef?.removeEventListener('keydown', handleDocumentKeydown);\n    };\n    return {\n        attachInput,\n        detachInput,\n        focusInput,\n        destroy\n    };\n}\n", "const EMPTY_SNAPSHOT = {\n    correctCpm: 0,\n    totalCpm: 0,\n    wpm: 0,\n    accuracy: 100,\n    durationMs: 0,\n    totalChars: 0\n};\nexport function createDomStatsPanel({ getLocaleText, realtime = {}, result = {} } = {}) {\n    const secondsLabel = () => getLocaleText?.('ui.statsLabels.seconds') || '秒';\n    return {\n        renderSnapshot: (snapshot) => renderRealtime(snapshot ?? EMPTY_SNAPSHOT, realtime, secondsLabel),\n        renderResults: (snapshot) => renderResults(snapshot ?? EMPTY_SNAPSHOT, result, secondsLabel),\n        reset: () => renderRealtime(EMPTY_SNAPSHOT, realtime, secondsLabel)\n    };\n}\nfunction renderRealtime(snapshot, elements, label) {\n    setText(elements.cpm, formatNumber(snapshot.correctCpm));\n    setText(elements.totalCpm, formatNumber(snapshot.totalCpm));\n    setText(elements.wpm, formatNumber(snapshot.wpm));\n    setText(elements.accuracy, `${formatNumber(snapshot.accuracy, 100)}%`);\n    setText(elements.time, formatDuration(snapshot.durationMs, label));\n    setText(elements.chars, formatNumber(snapshot.totalChars));\n}\nfunction renderResults(snapshot, elements, label) {\n    setText(elements.time, formatDuration(snapshot.durationMs, label));\n    setText(elements.cpm, formatNumber(snapshot.correctCpm));\n    setText(elements.totalCpm, formatNumber(snapshot.totalCpm));\n    setText(elements.wpm, formatNumber(snapshot.wpm));\n    setText(elements.accuracy, `${formatNumber(snapshot.accuracy, 100)}%`);\n    setText(elements.chars, formatNumber(snapshot.totalChars));\n}\nfunction setText(node, value) {\n    if (!node)\n        return;\n    node.textContent = String(value);\n}\nfunction formatNumber(value, fallback = 0) {\n    return Number.isFinite(value) ? value : fallback;\n}\nfunction formatDuration(durationMs, secondsLabel) {\n    const elapsedSeconds = Math.max(0, durationMs) / 1000;\n    return `${elapsedSeconds.toFixed(1).padStart(6, ' ')}${secondsLabel()}`;\n}\n", "const DEFAULT_THEMES = ['dracula', 'serika', 'botanical', 'aether', 'nord'];\nexport function createDomThemeController(options = {}) {\n    const documentRef = options.documentRef ?? (typeof document !== 'undefined' ? document : undefined);\n    const storage = options.storage ?? (typeof localStorage !== 'undefined' ? localStorage : undefined);\n    const selector = options.selector ?? '.theme-option';\n    const target = options.target ?? (typeof document !== 'undefined' ? document.body : undefined);\n    const themes = normalizeThemes(options.themes);\n    const defaultTheme = normalizeDefaultTheme(options.defaultTheme, themes);\n    const storageKey = options.storageKey ?? 'theme';\n    let mountedElements = [];\n    let activeTheme = getStoredTheme();\n    function getStoredTheme() {\n        const stored = storage?.getItem(storageKey);\n        return isValidTheme(stored, themes) ? stored : defaultTheme;\n    }\n    function persistTheme(theme) {\n        storage?.setItem(storageKey, theme);\n    }\n    function getThemeElements() {\n        if (!documentRef || typeof documentRef.querySelectorAll !== 'function') {\n            return [];\n        }\n        const nodes = documentRef.querySelectorAll(selector);\n        return Array.from(nodes);\n    }\n    function applyThemeInternal(theme) {\n        const normalized = isValidTheme(theme, themes) ? theme : defaultTheme;\n        if (target?.classList) {\n            themes.forEach((name) => target.classList.remove(`theme-${name}`));\n            if (normalized !== defaultTheme) {\n                target.classList.add(`theme-${normalized}`);\n            }\n        }\n        options.onThemeChange?.(normalized);\n        return normalized;\n    }\n    function syncActiveClass(elements, theme) {\n        elements.forEach((element) => {\n            const itemTheme = element.getAttribute?.('data-theme');\n            if (!itemTheme || !element.classList)\n                return;\n            if (itemTheme === theme) {\n                element.classList.add('active');\n            }\n            else {\n                element.classList.remove('active');\n            }\n        });\n    }\n    function applyThemePublic(theme) {\n        activeTheme = applyThemeInternal(theme);\n        persistTheme(activeTheme);\n        if (mountedElements.length === 0) {\n            mountedElements = getThemeElements();\n        }\n        syncActiveClass(mountedElements, activeTheme);\n        return activeTheme;\n    }\n    function init() {\n        mountedElements = getThemeElements();\n        activeTheme = applyThemeInternal(getStoredTheme());\n        syncActiveClass(mountedElements, activeTheme);\n        const listeners = mountedElements.map((element) => {\n            const handler = () => {\n                const theme = element.getAttribute?.('data-theme') ?? undefined;\n                if (!theme || theme === activeTheme)\n                    return;\n                activeTheme = applyThemeInternal(theme);\n                persistTheme(activeTheme);\n                syncActiveClass(mountedElements, activeTheme);\n            };\n            element.addEventListener?.('click', handler);\n            return () => element.removeEventListener?.('click', handler);\n        });\n        return () => {\n            listeners.forEach((unsubscribe) => unsubscribe());\n            mountedElements = [];\n        };\n    }\n    return {\n        getActiveTheme: () => activeTheme,\n        applyTheme: applyThemePublic,\n        init\n    };\n}\nfunction normalizeThemes(themes) {\n    if (themes && themes.length > 0) {\n        return Array.from(new Set(themes));\n    }\n    return [...DEFAULT_THEMES];\n}\nfunction normalizeDefaultTheme(defaultTheme, themes) {\n    if (defaultTheme && isValidTheme(defaultTheme, themes)) {\n        return defaultTheme;\n    }\n    return themes[0];\n}\nfunction isValidTheme(theme, themes) {\n    if (!theme)\n        return false;\n    return themes.includes(theme);\n}\n", "const DEFAULT_ATTACH_TO_PREVIOUS = new Set([\n    '，',\n    '。',\n    '！',\n    '？',\n    '：',\n    '；',\n    '、',\n    '）',\n    '】',\n    '》',\n    '』',\n    '」',\n    '’',\n    '”',\n    '…',\n    '—'\n]);\nconst DEFAULT_ATTACH_TO_NEXT = new Set(['（', '【', '《', '『', '「', '“', '‘']);\nexport function createDomTextRenderer(textDisplay, options = {}) {\n    const doc = options.documentRef ?? (typeof document !== 'undefined' ? document : undefined);\n    const preserveChildren = options.preserveChildren ?? false;\n    const textContentClass = options.textContentClass ?? 'pitype-text-content';\n    const normalizedLineBreakOptions = normalizeLineBreakOptions(options.lineBreakOptions);\n    const shouldApplyLineBreakRules = hasLineBreakRules(normalizedLineBreakOptions);\n    let charSpans = [];\n    const render = (source) => {\n        if (!textDisplay || !source || !doc)\n            return;\n        const tokens = source.tokens ?? [];\n        const fragment = doc.createDocumentFragment();\n        let currentWord = null;\n        const lineBreakDecisions = shouldApplyLineBreakRules\n            ? computeLineBreakDecisions(tokens, normalizedLineBreakOptions)\n            : [];\n        const flushWord = () => {\n            if (currentWord) {\n                fragment.appendChild(currentWord);\n                currentWord = null;\n            }\n        };\n        const ensureWord = (language) => {\n            if (!currentWord) {\n                currentWord = doc.createElement('span');\n                currentWord.classList.add('word');\n                if (language === 'english') {\n                    currentWord.classList.add('english-word');\n                }\n                if (language === 'chinese') {\n                    currentWord.classList.add('chinese-char');\n                }\n                currentWord.dataset.language = language || 'other';\n            }\n            return currentWord;\n        };\n        let previousRenderableSpan = null;\n        let pendingAttachToNext = false;\n        tokens.forEach((token, index) => {\n            if (token.type === 'newline') {\n                flushWord();\n                const wrapper = doc.createElement('span');\n                wrapper.classList.add('word');\n                const lineBreak = doc.createElement('span');\n                lineBreak.classList.add('line-break');\n                lineBreak.setAttribute('data-char', '\\n');\n                wrapper.appendChild(lineBreak);\n                fragment.appendChild(wrapper);\n                fragment.appendChild(doc.createElement('br'));\n                if (shouldApplyLineBreakRules) {\n                    previousRenderableSpan = null;\n                    pendingAttachToNext = false;\n                }\n                return;\n            }\n            const shouldReuseWord = token.type === 'char' &&\n                token.language === 'english' &&\n                currentWord &&\n                currentWord.dataset.language === 'english';\n            if (!shouldReuseWord && !(token.attachToPrevious && currentWord)) {\n                flushWord();\n            }\n            const word = token.attachToPrevious && currentWord ? currentWord : ensureWord(token.language);\n            const previousSpan = shouldApplyLineBreakRules ? previousRenderableSpan : null;\n            const span = createTokenSpan(token, doc);\n            word.appendChild(span);\n            let currentDecision;\n            let nextDecision;\n            if (shouldApplyLineBreakRules) {\n                currentDecision = lineBreakDecisions[index];\n                nextDecision = lineBreakDecisions[index + 1];\n                if (pendingAttachToNext && previousSpan) {\n                    applyNoBreak(previousSpan, span);\n                }\n                pendingAttachToNext = false;\n                if (currentDecision?.attachToPrevious && previousSpan) {\n                    applyNoBreak(previousSpan, span);\n                }\n                if (currentDecision?.attachToNext) {\n                    pendingAttachToNext = true;\n                }\n            }\n            const shouldKeepWordForNext = shouldApplyLineBreakRules &&\n                Boolean(currentDecision?.attachToNext || nextDecision?.attachToPrevious);\n            const shouldFlushChineseChar = token.language === 'chinese' &&\n                token.type === 'char' &&\n                (!shouldApplyLineBreakRules || !shouldKeepWordForNext);\n            const shouldFlushSpace = token.type === 'space';\n            const shouldFlushPunctuation = token.type === 'punctuation' && !(shouldApplyLineBreakRules && shouldKeepWordForNext);\n            if (shouldFlushChineseChar) {\n                flushWord();\n            }\n            if (shouldFlushSpace || shouldFlushPunctuation) {\n                flushWord();\n            }\n            if (shouldApplyLineBreakRules) {\n                previousRenderableSpan = span;\n            }\n        });\n        flushWord();\n        const contentWrapper = doc.createElement('div');\n        contentWrapper.classList.add(textContentClass);\n        contentWrapper.appendChild(fragment);\n        if (preserveChildren) {\n            const existing = Array.from(textDisplay.querySelectorAll(`.${textContentClass}`));\n            existing.forEach((node) => node.remove());\n            textDisplay.insertBefore(contentWrapper, textDisplay.firstChild);\n        }\n        else {\n            textDisplay.innerHTML = '';\n            textDisplay.appendChild(contentWrapper);\n        }\n        charSpans = [];\n    };\n    const setSpans = (spans = []) => {\n        charSpans = Array.isArray(spans) ? spans : [];\n    };\n    const getSpans = () => charSpans;\n    const getSpanByIndex = (index) => {\n        if (index == null || index < 0 || index >= charSpans.length)\n            return null;\n        return charSpans[index];\n    };\n    const applySpanState = (index, correct) => {\n        const span = getSpanByIndex(index);\n        if (!span)\n            return;\n        span.classList.remove('correct', 'incorrect');\n        span.classList.add(correct ? 'correct' : 'incorrect');\n    };\n    const resetSpanState = (index) => {\n        const span = getSpanByIndex(index);\n        if (!span)\n            return;\n        span.classList.remove('correct', 'incorrect');\n    };\n    return {\n        render,\n        setSpans,\n        getSpans,\n        applySpanState,\n        resetSpanState\n    };\n}\nfunction createTokenSpan(token, doc) {\n    if (token.type === 'space') {\n        const wrapper = doc.createElement('span');\n        wrapper.classList.add(token.attachToPrevious ? 'no-break' : 'word-space');\n        wrapper.setAttribute('data-char', ' ');\n        const inner = doc.createElement('span');\n        inner.classList.add('char-space');\n        inner.innerHTML = '&nbsp;';\n        wrapper.appendChild(inner);\n        return wrapper;\n    }\n    if (token.type === 'punctuation') {\n        const punctuation = doc.createElement('span');\n        punctuation.setAttribute('data-char', token.char);\n        punctuation.textContent = token.char;\n        if (token.attachToPrevious) {\n            punctuation.classList.add('no-break');\n        }\n        return punctuation;\n    }\n    const span = doc.createElement('span');\n    span.setAttribute('data-char', token.char);\n    span.textContent = token.char;\n    return span;\n}\nfunction computeLineBreakDecisions(tokens, options) {\n    const decisions = new Array(tokens.length);\n    let previousRenderableToken;\n    tokens.forEach((token, index) => {\n        if (token.type === 'newline') {\n            decisions[index] = undefined;\n            previousRenderableToken = undefined;\n            return;\n        }\n        const decision = evaluateLineBreakDecision({\n            token,\n            index,\n            tokens,\n            previousToken: previousRenderableToken,\n            nextToken: tokens[index + 1]\n        }, options);\n        decisions[index] = decision;\n        previousRenderableToken = token;\n    });\n    return decisions;\n}\nfunction normalizeLineBreakOptions(options) {\n    const attachToPreviousChars = new Set(options?.attachToPreviousChars ?? []);\n    const attachToNextChars = new Set(options?.attachToNextChars ?? []);\n    if (!options?.disableDefaultCjk) {\n        DEFAULT_ATTACH_TO_PREVIOUS.forEach((char) => attachToPreviousChars.add(char));\n        DEFAULT_ATTACH_TO_NEXT.forEach((char) => attachToNextChars.add(char));\n    }\n    return {\n        attachToPreviousChars,\n        attachToNextChars,\n        matchers: options?.matchers ?? []\n    };\n}\nfunction hasLineBreakRules(options) {\n    return (options.attachToPreviousChars.size > 0 ||\n        options.attachToNextChars.size > 0 ||\n        options.matchers.length > 0);\n}\nfunction evaluateLineBreakDecision(context, options) {\n    let decision;\n    if (options.attachToPreviousChars.has(context.token.char)) {\n        decision = { ...(decision ?? {}), attachToPrevious: true };\n    }\n    if (options.attachToNextChars.has(context.token.char)) {\n        decision = { ...(decision ?? {}), attachToNext: true };\n    }\n    for (const matcher of options.matchers) {\n        const result = matcher(context);\n        if (!result)\n            continue;\n        decision = {\n            attachToPrevious: decision?.attachToPrevious || result.attachToPrevious,\n            attachToNext: decision?.attachToNext || result.attachToNext\n        };\n    }\n    return decision;\n}\nfunction applyNoBreak(previousSpan, currentSpan) {\n    previousSpan.classList.add('no-break');\n    currentSpan.classList.add('no-break');\n}\n", "const cursorAnimationPreferenceKey = 'cursorAnimationMode';\nconst cursorShapePreferenceKey = 'cursorShape';\nconst cursorColorPreferenceKey = 'cursorColor';\nconst cursorBlinkPreferenceKey = 'cursorBlinkEnabled';\nconst cursorAnimationDurations = {\n    off: 0,\n    slow: 150,\n    medium: 115,\n    fast: 85\n};\nconst cursorMinimums = {\n    width: 2,\n    height: 16,\n    inputWidth: 30,\n    widthMultiplier: 1.5\n};\nconst cursorShapeDefaults = {\n    block: { widthMultiplier: 1, heightMultiplier: 1 },\n    line: { widthMultiplier: 0.15, heightMultiplier: 1 },\n    underline: { widthMultiplier: 1, heightMultiplier: 0.15 },\n    outline: { widthMultiplier: 1, heightMultiplier: 1 }\n};\nconst mobileUserAgentPattern = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;\nexport function createDomCursorAdapter(options) {\n    const { textDisplay, textContainer, getCurrentPosition, getCursor, getInput, getSpans = () => [], setSpans = () => { }, windowRef = typeof window !== 'undefined' ? window : undefined, documentRef = typeof document !== 'undefined' ? document : undefined, navigatorRef = typeof navigator !== 'undefined' ? navigator : undefined, requestAnimationFrame: requestAnimationFrameImpl = (cb) => windowRef?.requestAnimationFrame ? windowRef.requestAnimationFrame(cb) : (cb(Date.now()), 0), cancelAnimationFrame: cancelAnimationFrameImpl = (handle) => windowRef?.cancelAnimationFrame?.(handle), performanceNow = () => windowRef?.performance?.now?.() ?? Date.now(), localStorage = windowRef?.localStorage, resizeObserverCtor = typeof ResizeObserver !== 'undefined' ? ResizeObserver : undefined, cursorShape: initialCursorShape, cursorColor: initialCursorColor, cursorBlinkEnabled: initialCursorBlinkEnabled, cursorBlinkRate = 530 } = options;\n    let cursorUpdateScheduled = false;\n    let cursorAnimationFrameId = null;\n    let currentCursorMetrics = null;\n    let lastCursorY = 0;\n    let resizeObserver = null;\n    let resizeRefreshRaf = null;\n    let hasWindowResizeHandler = false;\n    let mobileSupportAttached = false;\n    // 光标外观状态\n    let currentCursorShape = loadCursorShape();\n    let currentCursorColor = loadCursorColor();\n    let currentCursorBlinkEnabled = loadCursorBlinkEnabled();\n    // 从 localStorage 或初始配置加载光标形状\n    function loadCursorShape() {\n        if (initialCursorShape)\n            return initialCursorShape;\n        const stored = localStorage?.getItem(cursorShapePreferenceKey);\n        if (stored &&\n            (stored === 'block' || stored === 'line' || stored === 'underline' || stored === 'outline')) {\n            return stored;\n        }\n        return 'block';\n    }\n    // 从 localStorage 或初始配置加载光标颜色\n    function loadCursorColor() {\n        if (initialCursorColor)\n            return initialCursorColor;\n        return localStorage?.getItem(cursorColorPreferenceKey) || null;\n    }\n    // 从 localStorage 或初始配置加载闪烁设置\n    function loadCursorBlinkEnabled() {\n        if (initialCursorBlinkEnabled !== undefined)\n            return initialCursorBlinkEnabled;\n        const stored = localStorage?.getItem(cursorBlinkPreferenceKey);\n        if (stored !== null)\n            return stored === 'true';\n        return false;\n    }\n    // 应用光标外观样式\n    function applyCursorStyle(cursor) {\n        // 移除所有形状类\n        cursor.classList.remove('cursor-block', 'cursor-line', 'cursor-underline', 'cursor-outline');\n        // 添加当前形状类\n        cursor.classList.add(`cursor-${currentCursorShape}`);\n        // 应用自定义颜色\n        if (currentCursorColor) {\n            if (currentCursorShape === 'outline') {\n                cursor.style.borderColor = currentCursorColor;\n                cursor.style.backgroundColor = 'transparent';\n            }\n            else {\n                cursor.style.backgroundColor = currentCursorColor;\n            }\n        }\n        else {\n            cursor.style.backgroundColor = '';\n            cursor.style.borderColor = '';\n        }\n        // 应用闪烁效果\n        if (currentCursorBlinkEnabled) {\n            cursor.style.animation = `cursor-blink ${cursorBlinkRate}ms step-end infinite`;\n        }\n        else {\n            cursor.style.animation = '';\n        }\n    }\n    function cacheCharSpans() {\n        if (!textDisplay || !documentRef) {\n            setSpans([]);\n            return [];\n        }\n        const wordSpans = textDisplay.querySelectorAll?.('.word') ?? [];\n        const measured = [];\n        wordSpans.forEach((wordSpan) => {\n            const children = wordSpan.children ?? [];\n            for (let i = 0; i < children.length; i++) {\n                const span = children[i];\n                if (span.classList?.contains('line-break')) {\n                    measured.push({\n                        element: span,\n                        rect: span.getBoundingClientRect(),\n                        dataChar: '\\n'\n                    });\n                    continue;\n                }\n                if (span.classList?.contains('word-space') || span.classList?.contains('no-break')) {\n                    measured.push({\n                        element: span,\n                        rect: span.getBoundingClientRect(),\n                        dataChar: span.getAttribute('data-char') || ' '\n                    });\n                }\n                else if (span.getAttribute?.('data-char')) {\n                    measured.push({\n                        element: span,\n                        rect: span.getBoundingClientRect(),\n                        dataChar: span.getAttribute('data-char')\n                    });\n                }\n                else {\n                    const innerSpans = span.querySelectorAll?.('[data-char]') ?? [];\n                    innerSpans.forEach((innerSpan) => {\n                        const htmlSpan = innerSpan;\n                        if (!htmlSpan.parentElement?.classList?.contains('word-space') &&\n                            !htmlSpan.parentElement?.classList?.contains('no-break')) {\n                            measured.push({\n                                element: htmlSpan,\n                                rect: htmlSpan.getBoundingClientRect(),\n                                dataChar: htmlSpan.getAttribute('data-char')\n                            });\n                        }\n                    });\n                }\n            }\n        });\n        measured.sort((a, b) => {\n            const rowDiff = a.rect.top - b.rect.top;\n            if (Math.abs(rowDiff) > 5) {\n                return rowDiff;\n            }\n            return a.rect.left - b.rect.left;\n        });\n        const ordered = measured.map((item) => item.element);\n        setSpans(Array.from(ordered));\n        return ordered;\n    }\n    function scheduleRefresh() {\n        if (cursorUpdateScheduled)\n            return;\n        cursorUpdateScheduled = true;\n        requestAnimationFrameImpl(() => {\n            cursorUpdateScheduled = false;\n            updatePosition({ immediate: false });\n        });\n    }\n    function updatePosition(options = { immediate: false }) {\n        const cursor = getCursor();\n        const input = getInput();\n        if (!cursor || !input || !textDisplay)\n            return;\n        // 确保光标和输入框在 textDisplay 内部（自动修复 DOM 结构）\n        // 只在真实 DOM 环境中执行（测试环境中 contains 可能不存在）\n        if (typeof textDisplay.contains === 'function') {\n            if (!textDisplay.contains(cursor)) {\n                textDisplay.appendChild(cursor);\n                if (typeof console !== 'undefined' && console.warn) {\n                    console.warn('[pitype-core] DomCursorAdapter: 光标元素已自动移动到 textDisplay 内部。' +\n                        '建议在创建光标时直接使用 textDisplay.appendChild(cursor) 来避免此警告。');\n                }\n            }\n            if (!textDisplay.contains(input)) {\n                textDisplay.appendChild(input);\n                if (typeof console !== 'undefined' && console.warn) {\n                    console.warn('[pitype-core] DomCursorAdapter: 输入框元素已自动移动到 textDisplay 内部。' +\n                        '建议在创建输入框时直接使用 textDisplay.appendChild(input) 来避免此警告。');\n                }\n            }\n        }\n        let spans = getSpans();\n        if (!spans || spans.length === 0) {\n            spans = cacheCharSpans();\n        }\n        const position = getCurrentPosition();\n        if (position < 0 || position >= spans.length)\n            return;\n        const currentChar = spans[position];\n        if (!currentChar)\n            return;\n        const textRect = textDisplay.getBoundingClientRect();\n        const charRect = currentChar.getBoundingClientRect();\n        const top = charRect.top - textRect.top + (textDisplay.scrollTop ?? 0);\n        const left = charRect.left - textRect.left + (textDisplay.scrollLeft ?? 0);\n        const width = Math.max(charRect.width, cursorMinimums.width);\n        const height = Math.max(charRect.height, cursorMinimums.height);\n        animateCursorTo({\n            left,\n            top,\n            width,\n            height\n        }, { immediate: options.immediate ?? false }, cursor, input);\n        if (!cursor.classList.contains('cursor-visible')) {\n            cursor.classList.add('cursor-visible');\n        }\n        const previousCursorY = lastCursorY;\n        const currentCursorY = charRect.top;\n        const isLineChange = previousCursorY !== 0 && Math.abs(currentCursorY - previousCursorY) > 5;\n        if (isLineChange && textContainer?.scrollTo) {\n            const containerHeight = textContainer.clientHeight ?? 0;\n            textContainer.scrollTo({\n                top: top - containerHeight / 2 + height / 2,\n                behavior: 'smooth'\n            });\n            lastCursorY = currentCursorY;\n        }\n        else if (lastCursorY === 0) {\n            lastCursorY = currentCursorY;\n        }\n    }\n    function resetAnimation() {\n        if (cursorAnimationFrameId !== null) {\n            cancelAnimationFrameImpl?.(cursorAnimationFrameId);\n            cursorAnimationFrameId = null;\n        }\n        currentCursorMetrics = null;\n    }\n    function scheduleLayoutRefresh() {\n        if (resizeRefreshRaf !== null)\n            return;\n        resizeRefreshRaf = requestAnimationFrameImpl(() => {\n            resizeRefreshRaf = null;\n            cacheCharSpans();\n            lastCursorY = 0;\n            updatePosition({ immediate: true });\n        });\n    }\n    function enableResponsiveSync() {\n        if (hasWindowResizeHandler || !textContainer || !windowRef)\n            return;\n        const handler = scheduleLayoutRefresh;\n        windowRef.addEventListener?.('resize', handler);\n        hasWindowResizeHandler = true;\n        if (resizeObserverCtor) {\n            if (resizeObserver) {\n                resizeObserver.disconnect();\n            }\n            resizeObserver = new resizeObserverCtor(() => {\n                scheduleLayoutRefresh();\n            });\n            resizeObserver.observe(textContainer);\n        }\n    }\n    function enableMobileSupport() {\n        if (mobileSupportAttached || !textDisplay)\n            return;\n        if (navigatorRef && mobileUserAgentPattern.test(navigatorRef.userAgent ?? '')) {\n            textDisplay.addEventListener?.('click', () => {\n                const input = getInput();\n                input?.focus?.();\n            });\n        }\n        mobileSupportAttached = true;\n    }\n    function applyCursorMetrics(metrics, cursor, input) {\n        // 根据光标形状调整尺寸\n        const shapeConfig = cursorShapeDefaults[currentCursorShape];\n        const adjustedWidth = metrics.width * shapeConfig.widthMultiplier;\n        const adjustedHeight = metrics.height * shapeConfig.heightMultiplier;\n        // 对于 underline，调整垂直位置到字符底部\n        let adjustedTop = metrics.top;\n        if (currentCursorShape === 'underline') {\n            adjustedTop = metrics.top + metrics.height - adjustedHeight;\n        }\n        cursor.style.width = `${adjustedWidth}px`;\n        cursor.style.height = `${adjustedHeight}px`;\n        cursor.style.transform = `translate3d(${metrics.left}px, ${adjustedTop}px, 0)`;\n        // 应用光标外观样式（形状、颜色、闪烁）\n        applyCursorStyle(cursor);\n        const inputWidth = Math.max(metrics.width * cursorMinimums.widthMultiplier, cursorMinimums.inputWidth);\n        input.style.width = `${inputWidth}px`;\n        input.style.height = `${metrics.height}px`;\n        input.style.transform = `translate3d(${metrics.left}px, ${metrics.top}px, 0)`;\n        currentCursorMetrics = { ...metrics };\n    }\n    function animateCursorTo(targetMetrics, options, cursor, input) {\n        const duration = getCursorAnimationDuration();\n        const skipAnimation = options.immediate || shouldReduceMotion() || duration === 0 || !currentCursorMetrics;\n        if (cursorAnimationFrameId !== null) {\n            cancelAnimationFrameImpl?.(cursorAnimationFrameId);\n            cursorAnimationFrameId = null;\n        }\n        if (skipAnimation) {\n            applyCursorMetrics(targetMetrics, cursor, input);\n            return;\n        }\n        const from = { ...currentCursorMetrics };\n        const target = { ...targetMetrics };\n        const startTime = performanceNow();\n        const tick = (now) => {\n            const elapsed = now - startTime;\n            const progress = Math.min(1, elapsed / duration);\n            const eased = easeOutCubic(progress);\n            const nextState = {\n                left: lerp(from.left, target.left, eased),\n                top: lerp(from.top, target.top, eased),\n                width: lerp(from.width, target.width, eased),\n                height: lerp(from.height, target.height, eased)\n            };\n            applyCursorMetrics(nextState, cursor, input);\n            if (progress < 1) {\n                cursorAnimationFrameId = requestAnimationFrameImpl(tick);\n            }\n            else {\n                cursorAnimationFrameId = null;\n                applyCursorMetrics(target, cursor, input);\n            }\n        };\n        cursorAnimationFrameId = requestAnimationFrameImpl(tick);\n    }\n    function getCursorAnimationDuration() {\n        const stored = localStorage?.getItem(cursorAnimationPreferenceKey);\n        if (stored && stored in cursorAnimationDurations) {\n            return cursorAnimationDurations[stored];\n        }\n        return cursorAnimationDurations.fast;\n    }\n    function shouldReduceMotion() {\n        const reduceMotionQuery = windowRef?.matchMedia?.('(prefers-reduced-motion: reduce)') ?? null;\n        return !!reduceMotionQuery?.matches;\n    }\n    // 光标外观配置方法\n    function setCursorShape(shape) {\n        currentCursorShape = shape;\n        localStorage?.setItem(cursorShapePreferenceKey, shape);\n        const cursor = getCursor();\n        if (cursor) {\n            applyCursorStyle(cursor);\n            updatePosition({ immediate: true });\n        }\n    }\n    function setCursorColor(color) {\n        currentCursorColor = color;\n        localStorage?.setItem(cursorColorPreferenceKey, color);\n        const cursor = getCursor();\n        if (cursor)\n            applyCursorStyle(cursor);\n    }\n    function setCursorBlink(enabled) {\n        currentCursorBlinkEnabled = enabled;\n        localStorage?.setItem(cursorBlinkPreferenceKey, String(enabled));\n        const cursor = getCursor();\n        if (cursor)\n            applyCursorStyle(cursor);\n    }\n    function getCursorShape() {\n        return currentCursorShape;\n    }\n    function getCursorColor() {\n        return currentCursorColor;\n    }\n    function getCursorBlink() {\n        return currentCursorBlinkEnabled;\n    }\n    /**\n     * 便捷初始化方法：按正确顺序执行初始化步骤。\n     * 利用 updatePosition 中的自动 fallback 机制，无需手动调用 cacheCharSpans。\n     */\n    function initialize(opts = {}) {\n        const { enableMobile = true, enableResponsive = true } = opts;\n        // 1. 重置动画状态（清除之前的动画）\n        resetAnimation();\n        // 2. 更新位置（内部会自动调用 cacheCharSpans 和 DOM 结构验证）\n        updatePosition({ immediate: true });\n        // 3. 启用移动端支持\n        if (enableMobile) {\n            enableMobileSupport();\n        }\n        // 4. 启用响应式同步\n        if (enableResponsive) {\n            enableResponsiveSync();\n        }\n    }\n    return {\n        initialize,\n        cacheCharSpans,\n        updatePosition,\n        resetAnimation,\n        scheduleRefresh,\n        scheduleLayoutRefresh,\n        enableResponsiveSync,\n        enableMobileSupport,\n        setCursorShape,\n        setCursorColor,\n        setCursorBlink,\n        getCursorShape,\n        getCursorColor,\n        getCursorBlink\n    };\n}\nfunction lerp(from, to, progress) {\n    return from + (to - from) * progress;\n}\nfunction easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n}\n", "const audioEnabledKey = 'audioEnabled';\nconst audioVolumeKey = 'audioVolume';\nexport function createDomAudioController(options = {}) {\n    const { soundPack: initialSoundPack = {}, enabled: initialEnabled, volume: initialVolume, poolSize = 3, localStorage = typeof window !== 'undefined' ? window.localStorage : undefined, windowRef = typeof window !== 'undefined' ? window : undefined } = options;\n    // 音效池映射：每种音效类型对应一个池\n    const audioPools = new Map();\n    // 当前音效包\n    let currentSoundPack = { ...initialSoundPack };\n    // 当前状态\n    let currentVolume = loadVolume();\n    let currentEnabled = loadEnabled();\n    // 从 localStorage 或初始配置加载音量\n    function loadVolume() {\n        if (initialVolume !== undefined)\n            return Math.max(0, Math.min(1, initialVolume));\n        const stored = localStorage?.getItem(audioVolumeKey);\n        if (stored !== null && stored !== undefined) {\n            const parsed = parseFloat(stored);\n            if (!isNaN(parsed))\n                return Math.max(0, Math.min(1, parsed));\n        }\n        return 0.5;\n    }\n    // 从 localStorage 或初始配置加载启用状态\n    function loadEnabled() {\n        if (initialEnabled !== undefined)\n            return initialEnabled;\n        const stored = localStorage?.getItem(audioEnabledKey);\n        if (stored !== null)\n            return stored === 'true';\n        return false;\n    }\n    // 创建 Audio 元素\n    function createAudioElement(source) {\n        if (typeof source === 'string') {\n            try {\n                const AudioCtor = windowRef?.Audio || (typeof Audio !== 'undefined' ? Audio : null);\n                if (!AudioCtor)\n                    return null;\n                const audio = new AudioCtor(source);\n                audio.volume = currentVolume;\n                audio.preload = 'auto';\n                return audio;\n            }\n            catch (error) {\n                console.warn(`Failed to create audio element from URL: ${source}`, error);\n                return null;\n            }\n        }\n        else {\n            try {\n                // 克隆已有的 Audio 对象\n                const audio = source.cloneNode(true);\n                audio.volume = currentVolume;\n                return audio;\n            }\n            catch (error) {\n                console.warn('Failed to clone audio element', error);\n                return null;\n            }\n        }\n    }\n    // 初始化音效池\n    function initializePool(type) {\n        const source = currentSoundPack[type];\n        if (!source)\n            return;\n        const elements = [];\n        for (let i = 0; i < poolSize; i++) {\n            const audio = createAudioElement(source);\n            if (audio) {\n                elements.push(audio);\n            }\n        }\n        if (elements.length > 0) {\n            audioPools.set(type, {\n                elements,\n                currentIndex: 0\n            });\n        }\n    }\n    // 初始化所有音效池\n    function initializeAllPools() {\n        const types = ['keyPress', 'correct', 'error', 'complete'];\n        types.forEach((type) => {\n            if (currentSoundPack[type]) {\n                initializePool(type);\n            }\n        });\n    }\n    // 播放音效\n    function playSound(type) {\n        if (!currentEnabled)\n            return;\n        const pool = audioPools.get(type);\n        if (!pool || pool.elements.length === 0)\n            return;\n        const audio = pool.elements[pool.currentIndex];\n        if (!audio)\n            return;\n        // 更新池索引（循环）\n        pool.currentIndex = (pool.currentIndex + 1) % pool.elements.length;\n        // 重置播放位置并播放\n        try {\n            audio.currentTime = 0;\n            audio.volume = currentVolume;\n            // 使用 promise 播放，忽略错误（避免未交互时的警告）\n            const playPromise = audio.play();\n            if (playPromise !== undefined) {\n                playPromise.catch((error) => {\n                    // 忽略用户未交互导致的自动播放失败\n                    if (error.name !== 'NotAllowedError') {\n                        console.warn(`Failed to play sound: ${type}`, error);\n                    }\n                });\n            }\n        }\n        catch (error) {\n            console.warn(`Error playing sound: ${type}`, error);\n        }\n    }\n    // 设置音量\n    function setVolume(volume) {\n        currentVolume = Math.max(0, Math.min(1, volume));\n        localStorage?.setItem(audioVolumeKey, String(currentVolume));\n        // 更新所有音频元素的音量\n        audioPools.forEach((pool) => {\n            pool.elements.forEach((audio) => {\n                audio.volume = currentVolume;\n            });\n        });\n    }\n    // 获取音量\n    function getVolume() {\n        return currentVolume;\n    }\n    // 启用音频\n    function enable() {\n        currentEnabled = true;\n        localStorage?.setItem(audioEnabledKey, 'true');\n    }\n    // 禁用音频\n    function disable() {\n        currentEnabled = false;\n        localStorage?.setItem(audioEnabledKey, 'false');\n    }\n    // 切换音频状态\n    function toggle() {\n        if (currentEnabled) {\n            disable();\n        }\n        else {\n            enable();\n        }\n        return currentEnabled;\n    }\n    // 获取启用状态\n    function isEnabled() {\n        return currentEnabled;\n    }\n    // 更新音效包\n    function updateSoundPack(soundPack) {\n        currentSoundPack = { ...soundPack };\n        // 清理旧的音效池\n        audioPools.forEach((pool) => {\n            pool.elements.forEach((audio) => {\n                audio.pause();\n                audio.src = '';\n            });\n        });\n        audioPools.clear();\n        // 重新初始化音效池\n        initializeAllPools();\n    }\n    // 预加载所有音效\n    async function preloadSounds() {\n        const promises = [];\n        audioPools.forEach((pool) => {\n            pool.elements.forEach((audio) => {\n                const promise = new Promise((resolve) => {\n                    if (audio.readyState >= 2) {\n                        // 已经加载完成\n                        resolve();\n                    }\n                    else {\n                        audio.addEventListener('canplaythrough', () => resolve(), { once: true });\n                        audio.addEventListener('error', () => resolve(), { once: true });\n                        audio.load();\n                    }\n                });\n                promises.push(promise);\n            });\n        });\n        try {\n            await Promise.all(promises);\n        }\n        catch (error) {\n            console.warn('Some audio files failed to preload', error);\n        }\n    }\n    // 销毁控制器\n    function destroy() {\n        audioPools.forEach((pool) => {\n            pool.elements.forEach((audio) => {\n                audio.pause();\n                audio.src = '';\n            });\n        });\n        audioPools.clear();\n    }\n    // 初始化\n    initializeAllPools();\n    return {\n        playSound,\n        setVolume,\n        getVolume,\n        enable,\n        disable,\n        toggle,\n        isEnabled,\n        updateSoundPack,\n        preloadSounds,\n        destroy\n    };\n}\n", "export function createPlayer(options) {\n    const { recording, playbackSpeed: initialSpeed = 1.0, onEvent, onComplete, onProgress, progressInterval = 100 } = options;\n    let state = 'idle';\n    let currentSpeed = initialSpeed;\n    let currentEventIndex = 0;\n    let currentTime = 0;\n    let startPlayTime = 0;\n    let pausedTime = 0;\n    let eventTimer = null;\n    let progressTimer = null;\n    const events = recording.events;\n    const duration = events.length > 0 ? events[events.length - 1].timestamp - events[0].timestamp : 0;\n    function clearTimers() {\n        if (eventTimer !== null) {\n            clearTimeout(eventTimer);\n            eventTimer = null;\n        }\n        if (progressTimer !== null) {\n            clearInterval(progressTimer);\n            progressTimer = null;\n        }\n    }\n    function startProgressTimer() {\n        if (progressTimer !== null || !onProgress)\n            return;\n        progressTimer = setInterval(() => {\n            if (state === 'playing') {\n                onProgress(currentTime, duration);\n            }\n        }, progressInterval);\n    }\n    function stopProgressTimer() {\n        if (progressTimer !== null) {\n            clearInterval(progressTimer);\n            progressTimer = null;\n        }\n    }\n    function scheduleNextEvent() {\n        if (currentEventIndex >= events.length) {\n            complete();\n            return;\n        }\n        const currentEvent = events[currentEventIndex];\n        const nextEvent = events[currentEventIndex + 1];\n        // 触发当前事件\n        if (onEvent) {\n            onEvent(currentEvent, currentTime);\n        }\n        currentEventIndex++;\n        if (!nextEvent) {\n            // 没有下一个事件了，播放完成\n            complete();\n            return;\n        }\n        // 计算到下一个事件的延迟（考虑播放速度）\n        const delay = (nextEvent.timestamp - currentEvent.timestamp) / currentSpeed;\n        eventTimer = setTimeout(() => {\n            if (state === 'playing') {\n                currentTime = nextEvent.timestamp - events[0].timestamp;\n                scheduleNextEvent();\n            }\n        }, delay);\n    }\n    function play() {\n        if (state === 'playing')\n            return;\n        if (state === 'completed') {\n            // 重新开始\n            stop();\n        }\n        state = 'playing';\n        startPlayTime = Date.now() - pausedTime;\n        if (events.length === 0) {\n            complete();\n            return;\n        }\n        // 如果是从头开始，触发第一个事件\n        if (currentEventIndex === 0 && events.length > 0) {\n            const firstEvent = events[0];\n            if (onEvent) {\n                onEvent(firstEvent, 0);\n            }\n            currentEventIndex++;\n            currentTime = 0;\n        }\n        startProgressTimer();\n        scheduleNextEvent();\n    }\n    function pause() {\n        if (state !== 'playing')\n            return;\n        state = 'paused';\n        pausedTime = Date.now() - startPlayTime;\n        clearTimers();\n        stopProgressTimer();\n    }\n    function resume() {\n        if (state !== 'paused')\n            return;\n        play();\n    }\n    function stop() {\n        clearTimers();\n        stopProgressTimer();\n        state = 'idle';\n        currentEventIndex = 0;\n        currentTime = 0;\n        pausedTime = 0;\n        startPlayTime = 0;\n    }\n    function complete() {\n        clearTimers();\n        stopProgressTimer();\n        state = 'completed';\n        currentTime = duration;\n        if (onProgress) {\n            onProgress(duration, duration);\n        }\n        if (onComplete) {\n            onComplete();\n        }\n    }\n    function seek(timestamp) {\n        const wasPlaying = state === 'playing';\n        // 暂停播放\n        if (wasPlaying) {\n            pause();\n        }\n        // 限制时间范围\n        const clampedTime = Math.max(0, Math.min(timestamp, duration));\n        currentTime = clampedTime;\n        // 找到对应的事件索引\n        const absoluteTime = events[0].timestamp + clampedTime;\n        let newIndex = 0;\n        for (let i = 0; i < events.length; i++) {\n            if (events[i].timestamp <= absoluteTime) {\n                newIndex = i;\n            }\n            else {\n                break;\n            }\n        }\n        currentEventIndex = newIndex;\n        // 触发所有已经过的事件（可选：只触发最后一个状态）\n        if (onEvent && currentEventIndex < events.length) {\n            onEvent(events[currentEventIndex], currentTime);\n        }\n        // 如果之前在播放，继续播放\n        if (wasPlaying) {\n            resume();\n        }\n    }\n    function setSpeed(speed) {\n        const wasPlaying = state === 'playing';\n        if (wasPlaying) {\n            pause();\n        }\n        currentSpeed = Math.max(0.1, Math.min(10, speed));\n        if (wasPlaying) {\n            resume();\n        }\n    }\n    function getSpeed() {\n        return currentSpeed;\n    }\n    function getCurrentTime() {\n        return currentTime;\n    }\n    function getDuration() {\n        return duration;\n    }\n    function getState() {\n        return state;\n    }\n    function isPlaying() {\n        return state === 'playing';\n    }\n    function destroy() {\n        clearTimers();\n        stopProgressTimer();\n        state = 'idle';\n    }\n    return {\n        play,\n        pause,\n        resume,\n        stop,\n        seek,\n        setSpeed,\n        getSpeed,\n        getCurrentTime,\n        getDuration,\n        getState,\n        isPlaying,\n        destroy\n    };\n}\n/**\n * 获取录制数据的统计信息\n */\nexport function getRecordingStats(recording) {\n    const events = recording.events;\n    const duration = events.length > 0 ? events[events.length - 1].timestamp - events[0].timestamp : 0;\n    const inputCount = events.filter((e) => e.type === 'input:evaluate').length;\n    const undoCount = events.filter((e) => e.type === 'input:undo').length;\n    // 计算字符数（基于文本源）\n    const characterCount = recording.textSource.content.length;\n    return {\n        duration,\n        eventCount: events.length,\n        inputCount,\n        undoCount,\n        characterCount\n    };\n}\n", "import { createPlayer } from './player.js';\nimport { createDomCursorAdapter } from './dom/cursorAdapter.js';\nlet ghostIdCounter = 0;\nexport function createGhostManager(options) {\n    const { textDisplay, textContainer, getSpans, autoRemoveOnComplete = false, onGhostComplete } = options;\n    const ghosts = new Map();\n    function generateGhostId() {\n        return `ghost-${++ghostIdCounter}-${Date.now()}`;\n    }\n    function createGhostCursorElement(config) {\n        const cursorElement = document.createElement('div');\n        cursorElement.classList.add('cursor', 'ghost-cursor');\n        cursorElement.setAttribute('data-ghost-name', config.name);\n        // 设置透明度\n        const opacity = config.opacity !== undefined ? config.opacity : 0.6;\n        cursorElement.style.opacity = String(opacity);\n        // 设置 z-index 使其低于主光标\n        cursorElement.style.zIndex = '1';\n        textDisplay.appendChild(cursorElement);\n        return cursorElement;\n    }\n    function createGhostLabelElement(config) {\n        if (!config.showLabel)\n            return undefined;\n        const labelElement = document.createElement('div');\n        labelElement.classList.add('ghost-label');\n        labelElement.textContent = config.name;\n        labelElement.style.position = 'absolute';\n        labelElement.style.fontSize = '12px';\n        labelElement.style.padding = '2px 6px';\n        labelElement.style.borderRadius = '3px';\n        labelElement.style.backgroundColor = config.color || 'rgba(255, 255, 255, 0.8)';\n        labelElement.style.color = '#000';\n        labelElement.style.pointerEvents = 'none';\n        labelElement.style.whiteSpace = 'nowrap';\n        labelElement.style.transform = 'translateY(-20px)';\n        labelElement.style.zIndex = '3';\n        textDisplay.appendChild(labelElement);\n        return labelElement;\n    }\n    function updateLabelPosition(ghost) {\n        if (!ghost.labelElement)\n            return;\n        const cursorRect = ghost.cursorElement.getBoundingClientRect();\n        const textRect = textDisplay.getBoundingClientRect();\n        const left = cursorRect.left - textRect.left + (textDisplay.scrollLeft ?? 0);\n        const top = cursorRect.top - textRect.top + (textDisplay.scrollTop ?? 0);\n        ghost.labelElement.style.left = `${left}px`;\n        ghost.labelElement.style.top = `${top}px`;\n    }\n    function addGhost(config) {\n        const ghostId = generateGhostId();\n        // 创建虚拟输入框（幽灵不需要真实输入）\n        const dummyInput = document.createElement('input');\n        dummyInput.style.display = 'none';\n        // 创建光标元素\n        const cursorElement = createGhostCursorElement(config);\n        // 创建名称标签（可选）\n        const labelElement = createGhostLabelElement(config);\n        let currentPosition = 0;\n        // 创建光标适配器\n        const cursorAdapter = createDomCursorAdapter({\n            textDisplay,\n            textContainer,\n            getCurrentPosition: () => currentPosition,\n            getCursor: () => cursorElement,\n            getInput: () => dummyInput,\n            getSpans,\n            cursorShape: config.shape || 'line',\n            cursorColor: config.color || 'rgba(255, 215, 0, 0.8)',\n            cursorBlinkEnabled: false // 幽灵光标不闪烁\n        });\n        // 创建播放器\n        const player = createPlayer({\n            recording: config.recording,\n            onEvent: (event) => {\n                if (event.type === 'input:evaluate') {\n                    currentPosition = event.index + 1;\n                    cursorAdapter.updatePosition({ immediate: false });\n                    // 更新标签位置\n                    if (labelElement) {\n                        requestAnimationFrame(() => {\n                            const ghost = ghosts.get(ghostId);\n                            if (ghost)\n                                updateLabelPosition(ghost);\n                        });\n                    }\n                }\n                else if (event.type === 'input:undo') {\n                    currentPosition = event.index;\n                    cursorAdapter.updatePosition({ immediate: false });\n                    // 更新标签位置\n                    if (labelElement) {\n                        requestAnimationFrame(() => {\n                            const ghost = ghosts.get(ghostId);\n                            if (ghost)\n                                updateLabelPosition(ghost);\n                        });\n                    }\n                }\n            },\n            onComplete: () => {\n                onGhostComplete?.(ghostId);\n                if (autoRemoveOnComplete) {\n                    removeGhost(ghostId);\n                }\n            }\n        });\n        // 初始化光标位置\n        cursorAdapter.cacheCharSpans();\n        cursorAdapter.updatePosition({ immediate: true });\n        // 初始化标签位置\n        if (labelElement) {\n            updateLabelPosition({\n                id: ghostId,\n                config,\n                player,\n                cursorAdapter,\n                cursorElement,\n                labelElement,\n                currentPosition\n            });\n        }\n        const ghost = {\n            id: ghostId,\n            config,\n            player,\n            cursorAdapter,\n            cursorElement,\n            labelElement,\n            currentPosition\n        };\n        ghosts.set(ghostId, ghost);\n        return ghostId;\n    }\n    function removeGhost(ghostId) {\n        const ghost = ghosts.get(ghostId);\n        if (!ghost)\n            return;\n        ghost.player.destroy();\n        ghost.cursorElement.remove();\n        ghost.labelElement?.remove();\n        ghosts.delete(ghostId);\n    }\n    function getGhost(ghostId) {\n        return ghosts.get(ghostId);\n    }\n    function getAllGhosts() {\n        return Array.from(ghosts.values());\n    }\n    function startAll() {\n        ghosts.forEach((ghost) => {\n            ghost.player.play();\n        });\n    }\n    function pauseAll() {\n        ghosts.forEach((ghost) => {\n            ghost.player.pause();\n        });\n    }\n    function resumeAll() {\n        ghosts.forEach((ghost) => {\n            ghost.player.resume();\n        });\n    }\n    function stopAll() {\n        ghosts.forEach((ghost) => {\n            ghost.player.stop();\n        });\n    }\n    function setSpeedAll(speed) {\n        ghosts.forEach((ghost) => {\n            ghost.player.setSpeed(speed);\n        });\n    }\n    function destroy() {\n        ghosts.forEach((ghost) => {\n            ghost.player.destroy();\n            ghost.cursorElement.remove();\n            ghost.labelElement?.remove();\n        });\n        ghosts.clear();\n    }\n    return {\n        addGhost,\n        removeGhost,\n        getGhost,\n        getAllGhosts,\n        startAll,\n        pauseAll,\n        resumeAll,\n        stopAll,\n        setSpeedAll,\n        destroy\n    };\n}\n", "const localeRegistry = new Map();\nexport function registerLocale(locale) {\n    localeRegistry.set(locale.code, locale);\n}\nexport function getLocale(code) {\n    return localeRegistry.get(code);\n}\nexport function getLocaleString(code, key) {\n    const visited = new Set();\n    let currentCode = code;\n    while (currentCode) {\n        if (visited.has(currentCode))\n            break;\n        visited.add(currentCode);\n        const locale = localeRegistry.get(currentCode);\n        if (!locale)\n            break;\n        if (locale.strings[key] !== undefined) {\n            return locale.strings[key];\n        }\n        currentCode = locale.fallbackCode;\n    }\n    return undefined;\n}\nexport function clearLocales() {\n    localeRegistry.clear();\n}\n"],
  "mappings": "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",
  "names": ["ENGLISH_RE", "CHINESE_RE", "FULL_WIDTH_SPACE", "PUNCTUATION_SET", "Set", "tokenizeText", "text", "tokens", "i", "length", "char", "push", "type", "language", "attachToPrevious", "has", "test", "sourceCounter", "createTextSource", "content", "options", "Error", "id", "locale", "tokens", "tokenizeText", "TypingSession", "constructor", "options", "listeners", "Set", "entries", "position", "completed", "source", "createTextSourceFromOptions", "Error", "text", "content", "now", "Date", "tokens", "locale", "sourceId", "id", "subscribe", "listener", "add", "delete", "getState", "complete", "isComplete", "input", "chars", "char", "length", "startedAt", "undefined", "startSession", "expected", "timestamp", "correct", "equalsInput", "entry", "index", "actual", "push", "emit", "type", "undo", "count", "pop", "reset", "event", "forEach", "createTextSource", "createStatsTracker", "session", "StatsTrackerImpl", "constructor", "correctChars", "totalChars", "completed", "subscribe", "event", "handleEvent", "getSnapshot", "durationMs", "computeDuration", "minutes", "startedAt", "accuracy", "Math", "round", "correctCpm", "totalCpm", "wpm", "type", "timestamp", "lastTimestamp", "correct", "undefined", "last", "max", "createRecorder", "options", "id", "customId", "includeMetadata", "customMetadata", "recording", "_currentSession", "currentTextSource", "events", "startTime", "unsubscribe", "recordingId", "generateId", "Date", "now", "Math", "random", "toString", "substr", "start", "session", "textSource", "console", "warn", "subscribe", "event", "push", "stop", "finalStats", "endTime", "recordingData", "metadata", "version", "userAgent", "navigator", "duration", "eventCount", "length", "isRecording", "getCurrentRecording", "clear", "serializeRecording", "JSON", "stringify", "deserializeRecording", "json", "parse", "exportRecordingToFile", "filename", "window", "Blob", "Error", "blob", "type", "url", "URL", "createObjectURL", "a", "document", "createElement", "href", "download", "body", "appendChild", "click", "removeChild", "revokeObjectURL", "importRecordingFromFile", "file", "Promise", "resolve", "reject", "reader", "FileReader", "onload", "target", "result", "error", "onerror", "readAsText", "createSessionRuntime", "options", "interval", "snapshotIntervalMs", "audioController", "enableRecording", "recorderOptions", "typingSession", "statsTracker", "timer", "unsubscribe", "recorder", "createRecorder", "lastRecording", "currentTextSource", "getSnapshot", "notifySnapshot", "onSnapshot", "startTimer", "setInterval", "stopTimer", "clearInterval", "teardownSession", "handleSessionEvent", "event", "type", "onEvaluate", "playSound", "correct", "onUndo", "finalSnapshot", "isRecording", "stop", "undefined", "onComplete", "onReset", "dispose", "startSession", "input", "session", "createSessionFromInput", "createStatsTracker", "subscribe", "extractTextSource", "start", "getSession", "getLatestSnapshot", "getRecorder", "getLastRecording", "TypingSession", "text", "source", "content", "tokens", "tokenizeText", "id", "Date", "now", "locale", "compositionTriggerPattern", "createDomInputController", "options", "getTypingSession", "isResultModalVisible", "onCompositionEnd", "documentRef", "document", "undefined", "getActiveElement", "activeElement", "inputElement", "isComposing", "potentialCompositionStart", "handleInputEvent", "currentValue", "value", "tempState", "session", "inputChar", "input", "handlePotentialCompositionKeydown", "event", "key", "length", "test", "handlePotentialCompositionKeyup", "handleCompositionStart", "handleCompositionEnd", "focusInput", "focusOptions", "focus", "preventScroll", "handleDocumentKeydown", "isCharacterOperation", "preventDefault", "undo", "attachInput", "element", "detachInput", "addEventListener", "removeEventListener", "destroy", "EMPTY_SNAPSHOT", "correctCpm", "totalCpm", "wpm", "accuracy", "durationMs", "totalChars", "createDomStatsPanel", "getLocaleText", "realtime", "result", "secondsLabel", "renderSnapshot", "snapshot", "renderRealtime", "renderResults", "reset", "elements", "label", "setText", "cpm", "formatNumber", "time", "formatDuration", "chars", "node", "value", "textContent", "String", "fallback", "Number", "isFinite", "elapsedSeconds", "Math", "max", "toFixed", "padStart", "DEFAULT_THEMES", "createDomThemeController", "options", "documentRef", "document", "undefined", "storage", "localStorage", "selector", "target", "body", "themes", "normalizeThemes", "defaultTheme", "normalizeDefaultTheme", "storageKey", "mountedElements", "activeTheme", "getStoredTheme", "stored", "getItem", "isValidTheme", "persistTheme", "theme", "setItem", "getThemeElements", "querySelectorAll", "nodes", "Array", "from", "applyThemeInternal", "normalized", "classList", "forEach", "name", "remove", "add", "onThemeChange", "syncActiveClass", "elements", "element", "itemTheme", "getAttribute", "applyThemePublic", "length", "init", "listeners", "map", "handler", "addEventListener", "removeEventListener", "unsubscribe", "getActiveTheme", "applyTheme", "Set", "includes", "DEFAULT_ATTACH_TO_PREVIOUS", "Set", "DEFAULT_ATTACH_TO_NEXT", "createDomTextRenderer", "textDisplay", "options", "doc", "documentRef", "document", "undefined", "preserveChildren", "textContentClass", "normalizedLineBreakOptions", "normalizeLineBreakOptions", "lineBreakOptions", "shouldApplyLineBreakRules", "hasLineBreakRules", "charSpans", "render", "source", "tokens", "fragment", "createDocumentFragment", "currentWord", "lineBreakDecisions", "computeLineBreakDecisions", "flushWord", "appendChild", "ensureWord", "language", "createElement", "classList", "add", "dataset", "previousRenderableSpan", "pendingAttachToNext", "forEach", "token", "index", "type", "wrapper", "lineBreak", "setAttribute", "shouldReuseWord", "attachToPrevious", "word", "previousSpan", "span", "createTokenSpan", "currentDecision", "nextDecision", "applyNoBreak", "attachToNext", "shouldKeepWordForNext", "Boolean", "shouldFlushChineseChar", "shouldFlushSpace", "shouldFlushPunctuation", "contentWrapper", "existing", "Array", "from", "querySelectorAll", "node", "remove", "insertBefore", "firstChild", "innerHTML", "setSpans", "spans", "isArray", "getSpans", "getSpanByIndex", "length", "applySpanState", "correct", "resetSpanState", "inner", "punctuation", "char", "textContent", "decisions", "previousRenderableToken", "decision", "evaluateLineBreakDecision", "previousToken", "nextToken", "attachToPreviousChars", "attachToNextChars", "disableDefaultCjk", "matchers", "size", "context", "has", "matcher", "result", "currentSpan", "cursorAnimationPreferenceKey", "cursorShapePreferenceKey", "cursorColorPreferenceKey", "cursorBlinkPreferenceKey", "cursorAnimationDurations", "off", "slow", "medium", "fast", "cursorMinimums", "width", "height", "inputWidth", "widthMultiplier", "cursorShapeDefaults", "block", "heightMultiplier", "line", "underline", "outline", "mobileUserAgentPattern", "createDomCursorAdapter", "options", "textDisplay", "textContainer", "getCurrentPosition", "getCursor", "getInput", "getSpans", "setSpans", "windowRef", "window", "undefined", "documentRef", "document", "navigatorRef", "navigator", "requestAnimationFrame", "requestAnimationFrameImpl", "cb", "Date", "now", "cancelAnimationFrame", "cancelAnimationFrameImpl", "handle", "performanceNow", "performance", "localStorage", "resizeObserverCtor", "ResizeObserver", "cursorShape", "initialCursorShape", "cursorColor", "initialCursorColor", "cursorBlinkEnabled", "initialCursorBlinkEnabled", "cursorBlinkRate", "cursorUpdateScheduled", "cursorAnimationFrameId", "currentCursorMetrics", "lastCursorY", "resizeObserver", "resizeRefreshRaf", "hasWindowResizeHandler", "mobileSupportAttached", "currentCursorShape", "loadCursorShape", "currentCursorColor", "loadCursorColor", "currentCursorBlinkEnabled", "loadCursorBlinkEnabled", "stored", "getItem", "applyCursorStyle", "cursor", "classList", "remove", "add", "style", "borderColor", "backgroundColor", "animation", "cacheCharSpans", "wordSpans", "querySelectorAll", "measured", "forEach", "wordSpan", "children", "i", "length", "span", "contains", "push", "element", "rect", "getBoundingClientRect", "dataChar", "getAttribute", "innerSpans", "innerSpan", "htmlSpan", "parentElement", "sort", "a", "b", "rowDiff", "top", "Math", "abs", "left", "ordered", "map", "item", "Array", "from", "scheduleRefresh", "updatePosition", "immediate", "input", "appendChild", "console", "warn", "spans", "position", "currentChar", "textRect", "charRect", "scrollTop", "scrollLeft", "max", "animateCursorTo", "previousCursorY", "currentCursorY", "isLineChange", "scrollTo", "containerHeight", "clientHeight", "behavior", "resetAnimation", "scheduleLayoutRefresh", "enableResponsiveSync", "handler", "addEventListener", "disconnect", "observe", "enableMobileSupport", "test", "userAgent", "focus", "applyCursorMetrics", "metrics", "shapeConfig", "adjustedWidth", "adjustedHeight", "adjustedTop", "transform", "targetMetrics", "duration", "getCursorAnimationDuration", "skipAnimation", "shouldReduceMotion", "target", "startTime", "tick", "elapsed", "progress", "min", "eased", "easeOutCubic", "nextState", "lerp", "reduceMotionQuery", "matchMedia", "matches", "setCursorShape", "shape", "setItem", "setCursorColor", "color", "setCursorBlink", "enabled", "String", "getCursorShape", "getCursorColor", "getCursorBlink", "initialize", "opts", "enableMobile", "enableResponsive", "to", "t", "pow", "audioEnabledKey", "audioVolumeKey", "createDomAudioController", "options", "soundPack", "initialSoundPack", "enabled", "initialEnabled", "volume", "initialVolume", "poolSize", "localStorage", "window", "undefined", "windowRef", "audioPools", "Map", "currentSoundPack", "currentVolume", "loadVolume", "currentEnabled", "loadEnabled", "Math", "max", "min", "stored", "getItem", "parsed", "parseFloat", "isNaN", "createAudioElement", "source", "AudioCtor", "Audio", "audio", "preload", "error", "console", "warn", "cloneNode", "initializePool", "type", "elements", "i", "push", "length", "set", "currentIndex", "initializeAllPools", "types", "forEach", "playSound", "pool", "get", "currentTime", "playPromise", "play", "catch", "name", "setVolume", "setItem", "String", "getVolume", "enable", "disable", "toggle", "isEnabled", "updateSoundPack", "pause", "src", "clear", "preloadSounds", "promises", "promise", "Promise", "resolve", "readyState", "addEventListener", "once", "load", "all", "destroy", "createPlayer", "options", "recording", "playbackSpeed", "initialSpeed", "onEvent", "onComplete", "onProgress", "progressInterval", "state", "currentSpeed", "currentEventIndex", "currentTime", "startPlayTime", "pausedTime", "eventTimer", "progressTimer", "events", "duration", "length", "timestamp", "clearTimers", "clearTimeout", "clearInterval", "startProgressTimer", "setInterval", "stopProgressTimer", "scheduleNextEvent", "complete", "currentEvent", "nextEvent", "delay", "setTimeout", "play", "stop", "Date", "now", "firstEvent", "pause", "resume", "seek", "wasPlaying", "clampedTime", "Math", "max", "min", "absoluteTime", "newIndex", "i", "setSpeed", "speed", "getSpeed", "getCurrentTime", "getDuration", "getState", "isPlaying", "destroy", "getRecordingStats", "inputCount", "filter", "e", "type", "undoCount", "characterCount", "textSource", "content", "eventCount", "ghostIdCounter", "createGhostManager", "options", "textDisplay", "textContainer", "getSpans", "autoRemoveOnComplete", "onGhostComplete", "ghosts", "Map", "generateGhostId", "Date", "now", "createGhostCursorElement", "config", "cursorElement", "document", "createElement", "classList", "add", "setAttribute", "name", "opacity", "undefined", "style", "String", "zIndex", "appendChild", "createGhostLabelElement", "showLabel", "labelElement", "textContent", "position", "fontSize", "padding", "borderRadius", "backgroundColor", "color", "pointerEvents", "whiteSpace", "transform", "updateLabelPosition", "ghost", "cursorRect", "getBoundingClientRect", "textRect", "left", "scrollLeft", "top", "scrollTop", "addGhost", "ghostId", "dummyInput", "display", "currentPosition", "cursorAdapter", "createDomCursorAdapter", "getCurrentPosition", "getCursor", "getInput", "cursorShape", "shape", "cursorColor", "cursorBlinkEnabled", "player", "createPlayer", "recording", "onEvent", "event", "type", "index", "updatePosition", "immediate", "requestAnimationFrame", "get", "onComplete", "removeGhost", "cacheCharSpans", "id", "set", "destroy", "remove", "delete", "getGhost", "getAllGhosts", "Array", "from", "values", "startAll", "forEach", "play", "pauseAll", "pause", "resumeAll", "resume", "stopAll", "stop", "setSpeedAll", "speed", "setSpeed", "clear", "localeRegistry", "Map", "registerLocale", "locale", "set", "code", "getLocale", "get", "getLocaleString", "key", "visited", "Set", "currentCode", "has", "add", "strings", "undefined", "fallbackCode"]
}
